
#+AUTHOR: Jay Kamat
#+EMAIL: jaygkamat@gmail.com

# This is a docs page going over the basic setup of a DoCIF project.

* DoCIF Overview

DoCIF is the Docker Continuous Integration Framework.

Docker is a pretty cool technology, and it has enormous potential for making
testing much easier, but in practice, using docker is much harder than it sounds
for anything but the simplest setups. DoCIF aims to make setting up a new
project easier, both for newcomers and those who are seasoned docker testers!

Running testing in docker lets you:

1. Get the /exact/ build environment you want.
2. Ensure tests /always/ run in a clean environment (if you wish).
3. Allow saving state of any completed test so developers can reproduce an issue.
4. Cache images to the docker hub or your private registry (reducing dependency
   install times)

If you want to skip to setup, please go [[#simple-setup][to the setup section]].

* DoCIF Architecture

It's helpful to understand how DoCIF actually works behind the scenes before
setting up your first project. Make sure you know docker terminology before
reading this section.

** DoCIF Control Flow

DoCIF runs mostly in the host operating environment, preparing and running
docker containers that your tests will actually run in. For every DoCIF command
run, the ~config.docif~ file is sourced (providing DoCIF with important
information like the project root, Dockerfile location, git repo location) and
DoCIF will run a docker command based off the information provided.

For example, a 'run tests' command would first parse the ~config.docif~ file (to
find information about what tests to run), and then run a docker command that
actually executes the tests. This docker command automatically links the true
root of the project to the docker container (so we don't need to copy all the
files into your container, and so we can export artifacts). If you provided
custom link directories or environment variables to pass through, we pass them
here as well.

** DoCIF Commands

This section will go over what every DoCIF command does. This guide will mirror
the commands listed in [[file:~/Code/DoCIF/sample/circle.yml::machine:][the sample circle.yml]] almost exactly, as those are the
steps to a DoCIF run.

*** ~maketest.sh --pending~

This step runs entirely on the host system, with no docker involved at
all. Depending on your configuration, it will update the per-test status tokens
to 'pending'. We do this as early as possible so users can see the pending icon
as early as possible.

*** ~buildbaseimage.sh~

This step will install all the dependencies for your project. This step will be
the first step that actually runs in docker, and we'll only be running
~$SETUP_COMMAND~. Once this is completed, we'll commit the resulting container so we
can use it in the actual testing step.

If build caching is enabled, we'll push this image up to the docker hub. This
push is backgrounded, so it can upload while your tests are running.

(side note: if caching is enabled, we may not build this baseimage at all, and
we may pull it from the docker hub).

*** ~runtests.sh~

This step actually runs your tests! It will take the image that was generated by
~buildbaseimage.sh~, and run your test commands in it. Your test command's
aren't run directly from docker, but instead we call ~maketest.sh~, which is a
small shell script that will run each test one by one, and update status for
them as they complete (if status tokens are enabled). ~maketest.sh~ will also
store the output of every command so it can be uploaded as an artifact later on.

In this step, ~buildbaseimage.sh~ runs on the physical host, ~maketest.sh~ runs
inside docker (and launches your tests inside docker).

*** ~exit.sh~

This step runs entirely on the physical host, and simply returns a failure exit
code if ~runtests.sh~ failed. This allows us to run our tests in circleci's
dependency stage. CircleCi allows for caching things in the dependency, but not
the test stage, which you can take advantage of by setting ~$CACHE_DIRECTORIES~.

* Simple Setup
